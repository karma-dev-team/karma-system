Проблемы в этом проекте которые бы привели бы к катастрофе
------------

1) Черезмернная связанность, то есть модули приложения зависимы от base(что норма), но base зависим от модулей приложения. 
2) Все в одной папке, без какого либо явного обозначение к какому слою они принадлежат. 
3) Общая папка base содержит domain specific поведение, что должно было быть объявлено в загрузке модулей. 
4) Попытка в модульный монолит была неуспешной по этим причинам:
   1) Границы контекстов нарисованы НЕПРАВИЛЬНО. 
   2) Модульный монолит предполгает легкое разделение на микросервисы если необходимо, но в кодовой базе используется только одна база данных, 
      Также самое критическое, что все DTO, Entity, и Aggregate связаны между собой, хоть и должны связываться через подстановку их как интерфейс(LSP). 
5) Аггрегаты в тупую становились моделью данных, а должны быть доменными моделями, которые отвечает за свои инварианты. 
   Но этот принцип нарушался во всех Use-Case связанные с обновлением и изменением данных. 
6) Были сперва сделаны модели данных, и потом Usecases, что привело к тому что в доменных моделях появились не нужные данные, 
   И не правильные инварианты, и смешевание слоев.

Возможные решение многих этих проблем 
------------
Самое важное это определение самой системы, что она будет делать, какие функции иметь и т.д.
То есть не был проведен Event storming, также не был сделан документ спецификация всей системы.
Что привели к многим проблемам которые описаны выше.

Что касается кодовой базы: 
1) Не правильное использование архитектуры модульного монолита, по этим причинам: 
   1) Модульный монолит(дальше Модулит) предполагает что он будет разделен на микросервисы. что не было сделано должным образом 
   2) Обьяденить Server и Karma, или Auth и User, потом как они через мерно связанны с друг другом 
   3) Также необходимо переделать сервис files который не имеет дополнительных возможностей, как права, сохранение документов, удаление и т.д.  
   4) Исполльзвание LSP для внедрения зависимостей. 
   5) Связь между модулями осуществлялся напрямую через репозитории, который по понятным причинам нельзя получить доступ из другого сервиса. 
      Что надо заменить связь через интеракторы/сетевой вызов через aiohttp. 
   6) И самое важное не правильный выбор архитектуры, надо было сделать обычную гексоганальную архектиктуру без разделения 
      на сервисы внутри одного приложения. 
2) Что касается доменных событии, они диспатчились не правильно, и являлись не доменными событиями, а 
   Интеграционными событиями, главное отличие доменное событие он является внутри контекстным, 
   и не выходит из своего контекста, что не касается интеграционных. см. [microsoft](https://learn.microsoft.com/ru-ru/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/domain-events-design-implementation), [habr](https://habr.com/ru/companies/ispring/articles/569648/)
3) Решение второй проблемы, это создание более направленных событии, и обработчиков событии. 
   Вместо использования общего EventDispatcher, можно использовать отдельную группу обработчиков событии которые вызывались бы 
   внутри Usecase-ов.  
4) САМОЕ ВАЖНОЕ, НЕТУ ТЕСТОВ 